_Примечание: время указано в условных единицах_

**Дано: приложение, которое обрабатывает данные с инфраструктуры нефтеперерабатывающих и нефтедобывающих зводов. Речь идет о сборе метрик с датчиков.**
1. Нам критически важно, чтобы приложения работали без аварий, так как авария это перезапуск оборудования, то есть простой в один 36000 t.
2. Нам нельзя иметь время простоя больше 50 t, так как это повлечет собой неактуальные данные для принятия решения об изменении давления и может быть чревато разрушением инфраструктуры.
3. Чем чаще собираем данные с датчиков, тем больше удается нам экономить средств из-за уменьшения расходных материалов.
4. Оборудования три типа, с 512, 2048 и 5210 МБ. 
5. В определенный момент ПО оборудования обновили, и была установлена версия софта с дефектом, приводящим к истощению кучи.

_Данные с результатам в файле CompareGC.xlsx._

**Кратко для указанного кейса:**
1. Для нового оборудования с 5120 МБ памяти как G1, так и SerialGC.
2. Для старого оборудования с 512 и 2048 МБ памяти подходит только G1GC.
3. В случае установки ПО с дефектом лучше себя показал G1GC (смогли собрать больше данных до момента падения приложения, при этом само падение было раньше, то есть раньше обнаружили дефект).
**В целом по работе коллекторов:**
1. SerialGC активнее использует old-generation. Только в случае с 5210 МБ его не было. G1GC не использовал old-generation вплоть до момента, пока не была использована почти вся память (при неисправном ПО). В остальных кейсах old-generation не использовался, даже при 512 МБ. 
2. У G1GC сильно меньше максимальное время простоя (delay) из-за вызовов GC. Примерно в 10 раз меньше в сравнении с SerialGC для данного случая.
3. Сравнительно плохо себя показала default конфигурация, в ней не был установлен GC и Xms, Xms. Из-за отсутствия последних память все время прыгала от 1024 до 5196. Не смотря на установленный по умолчанию G1GC произволительность была близкой к худшему из контрольных замеров (SerialGC 512, хотя по факту доступной памяти было намного больше).
4. По умолчанию выбирается G1GC в современных версиях Java.
5. При нормальных условиях G1GC показывает стабильно меньшее количество вызовов GC, что благоприятно сказывается на общей времени задержки. При версии ПО с ошибкой - G1GC показал большее количество вызовов GC. Можно сделать вывод, что G1GC ведет себя достаточно интеллектуально, не форсирует лишние вызовы в моменты, когда нет проблем с производительностью и пытается изо всех сил оптимизировать память, когда наблюдаются очевидные нехватки.